// providers/ThreadRealtimeProvider.tsx
import {
  RealtimeMessageType,
  ThreadEventSchema,
  ThreadEventType,
} from "@/app/schemas/realtime";
import { orpc } from "@/lib/orpc";
import { useQueryClient } from "@tanstack/react-query";
import usePartySocket from "partysocket/react";
import { createContext, ReactNode, useContext, useMemo } from "react";

type ThreadRealtimeContextValue = {
  send: (event: ThreadEventType) => void;
};

interface ThreadRealtimeProviderProps {
  children: ReactNode;
  threadId: string;
}

const ThreadRealtimeContext = createContext<ThreadRealtimeContextValue | null>(
  null
);

export function ThreadRealtimeProvider({
  children,
  threadId,
}: ThreadRealtimeProviderProps) {
  const queryClient = useQueryClient();

  type ThreadListOptions = ReturnType<
    typeof orpc.message.thread.list.queryOptions
  >;

  type ThreadQueryData = Awaited<ReturnType<ThreadListOptions["queryFn"]>>;

  const socket = usePartySocket({
    host: "http://127.0.0.1:8787",
    room: `thread-${threadId}`,
    party: "chat",
    onMessage(e) {
      try {
        const parsed = JSON.parse(e.data);

        const result = ThreadEventSchema.safeParse(parsed);
        if (!result.success) {
          console.log("Invalid Thread Event");
          return;
        }

        const event = result.data;

        if (event.type === "thread:reply:created") {
          const replyObj = event.payload.reply as RealtimeMessageType;
          // Use the same key generated by orpc
          const listOptions = orpc.message.thread.list.queryOptions({
            input: { messageId: threadId },
          });

          queryClient.setQueryData<ThreadQueryData>(
            listOptions.queryKey,
            (old) => {
              if (!old) return old;

              const reply = {
                reactions: Array.isArray(replyObj.reactions)
                  ? replyObj.reactions
                  : [],
                ...replyObj,
              } as ThreadQueryData["messages"][number];

              return {
                ...old,
                messages: [...old.messages, reply],
              };
            }
          );

          return;
        }

        if (event.type === "thread:reaction:updated") {
          const { messageId, reactions, threadId: tId } = event.payload;

          if (tId !== threadId) {
            return;
          }

          // Use the same key generated by orpc
          const listOptions = orpc.message.thread.list.queryOptions({
            input: { messageId: threadId },
          });

          queryClient.setQueryData(listOptions.queryKey, (old) => {
            if (!old) return old;

            if (messageId === threadId) {
              return {
                ...old,
                parent: { ...old.parent, reactions },
              };
            }
            return {
              ...old,
              messages: old.messages.map((m) =>
                m.id === messageId ? { ...m, reactions } : m
              ),
            };
          });

          return;
        }
      } catch (error) {
        console.log("Something went wrong", error);
      }
    },
  });

  const value = useMemo<ThreadRealtimeContextValue>(() => {
    return {
      send: (event) => {
        socket.send(JSON.stringify(event));
      },
    };
  }, [socket]);

  return (
    <ThreadRealtimeContext.Provider value={value}>
      {children}
    </ThreadRealtimeContext.Provider>
  );
}

export function useThreadRealtime() {
  const ctx = useContext(ThreadRealtimeContext);

  if (!ctx) {
    throw new Error(
      "useThreadRealtime must be used within a thread realtime provider"
    );
  }

  return ctx;
}

export function useOptionalThreadRealtime(): ThreadRealtimeContextValue | null {
  return useContext(ThreadRealtimeContext);
}
